options {
  IGNORE_CASE = true;
  STATIC = false;
  BUILD_PARSER = true;
  LOOKAHEAD = 2;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(Sintaxis)
package Analizador;
public class Sintaxis {
    public static void main(String[] args) throws ParseException {
        Sintaxis parser = new Sintaxis(System.in);
        parser.Program();
    }
}
PARSER_END(Sintaxis)

/** Inicio del lexico **/

SKIP : {
    " "
  | "\t"
  | "\r"
  | "\n"
}

// Tokens de palabras reservadas
TOKEN : {
    < FN: "fn" >
  | < LET: "let" >
  | < MUT: "mut" >
  | < RETURN: "return" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < FOR: "for" >
  | < IN: "in" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < I32: "i32" >
  | < F64: "f64" >
  | < BOOL: "bool" >
  | < STR: "str" >
  | < STRING_KEYWORD: "String" >
  | < PRINTLN: "println!" >
}

// Tokens de operadores
TOKEN : {
    < PLUS: "+" >
  | < MINUS: "-" >
  | < MULTIPLICATION: "*" >
  | < DIVISION: "/" >
  | < MODULUS: "%" >
  | < EQUALTO: "==" >
  | < NOTEQUAL: "!=" >
  | < LESSTHAN: "<" >
  | < GREATERTHAN: ">" >
  | < LESSTHANEQUAL: "<=" >
  | < GREATERTHANEQUAL: ">=" >
  | < AND: "&&" >
  | < OR: "||" >
  | < NOT: "!" >
  | < EQUAL: "=" >
}

// Tokens de símbolos
TOKEN : {
    < LPARENT: "(" >
  | < RPARENT: ")" >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < COMMA: "," >
  | < PUNTOYCOMA: ";" >
  | < COLON: ":" >
  | < ARROW: "->" >
}

// Tokens de números y cadenas
TOKEN : {
    < INT: (["0"-"9"])+ >
  | < FLOAT: (["0"-"9"])+ "." (["0"-"9"])+ >
  | < STRING: "\"" (~["\""])* "\"" >
  | < IDENTIFIER: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
}


/** Fin Lexico **/

// Define el programa como una serie de declaraciones
void Program() : {}
{
    (Statement())*
}

// Define una declaración como una declaración de variable, una declaración de función, una estructura de control, una expresión o un bloque
void Statement() : {}
{
    VariableDeclaration()
  | FunctionDeclaration()
  | ControlStructure()
  | ExpressionStatement()
  | Block()
  | PrintStatement()
}

// Define una declaración de variable
void VariableDeclaration() : {}
{
    <LET> [<MUT>] <IDENTIFIER> [":" Type()] "=" Expression() <PUNTOYCOMA>
}

// Define una declaración de función
void FunctionDeclaration() : {}
{
    <FN> <IDENTIFIER> <LPARENT> [ParameterList()] <RPARENT> [ <ARROW> Type() ] Block()
}

// Define una lista de parámetros de función
void ParameterList() : {}
{
    Parameter() ( <COMMA> Parameter() )* | ""
}

// Define un parámetro de función
void Parameter() : {}
{
    <IDENTIFIER> <COLON> Type()
}

// Define una estructura de control
void ControlStructure() : {}
{
    IfStatement()
  | WhileStatement()
  | ForStatement()
}

// Define una declaración if
void IfStatement() : {}
{
    <IF> Expression() Block() [ <ELSE> Block() ]
}

// Define una declaración while
void WhileStatement() : {}
{
    <WHILE> Expression() Block()
}

// Define una declaración for
void ForStatement() : {}
{
    <FOR> <IDENTIFIER> <IN> Expression() "=" <INT> Block()
}

// Define un bloque de código
void Block() : {}
{
    <LBRACE> (Statement())* <RBRACE>
}

// Define una expresión
void ExpressionStatement() : {}
{
    Expression() <PUNTOYCOMA>
}

// Define una expresión, que puede ser un literal, un identificador, una llamada a función, una operación binaria, una operación unaria, o una expresión entre paréntesis
void Expression() : {}
{
    PrimaryExpression() (BinaryOperator() PrimaryExpression())*
}

// Define un literal
void PrimaryExpression() : {}
{
    Literal()
  | <IDENTIFIER>
  | FunctionCall()
  | <LPARENT> Expression() <RPARENT>
}

// Define un literal
void Literal() : {}
{
    <INT>
  | <FLOAT>
  | <STRING>
  | <TRUE>
  | <FALSE>
}

// Define una llamada a función
void FunctionCall() : {}
{
    <IDENTIFIER> <LPARENT> [ArgumentList()] <RPARENT>
}

// Define una lista de argumentos
void ArgumentList() : {}
{
    Expression() ( <COMMA> Expression() )* | ""
}

// Define una operación binaria
void BinaryOperator() : {}
{
    <PLUS> | <MINUS> | <MULTIPLICATION> | <DIVISION> | <EQUALTO> | <NOTEQUAL> | <LESSTHAN> | <GREATERTHAN> | <LESSTHANEQUAL> | <GREATERTHANEQUAL>
}

// Define una operación unaria
void UnaryOperation() : {}
{
    UnaryOperator() PrimaryExpression()
}

// Define un operador unario
void UnaryOperator() : {}
{
    <NOT> | <MINUS>
}
void PrintStatement() : {}
{
    <PRINTLN> <LPARENT> [ArgumentList()] <RPARENT> <PUNTOYCOMA>
}

// Define un tipo de dato
void Type() : {}
{
    <I32> |
    <F64> |
    <BOOL> |
    <STR> |
    <STRING_KEYWORD> |
    <IDENTIFIER>
}
