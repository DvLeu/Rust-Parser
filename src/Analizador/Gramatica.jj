options {
  IGNORE_CASE = true;
  STATIC = false;
  BUILD_PARSER = true;
  LOOKAHEAD = 2;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(Sintaxis)
package Analizador;
public class Sintaxis {
    public static void main(String[] args) throws ParseException {
        Sintaxis parser = new Sintaxis(System.in);
        parser.Program();
    }
}
PARSER_END(Sintaxis)

/** Inicio del lexico **/

SKIP : {
    " "
  | "\t"
  | "\r"
  | "\n"
  | < "/" (~[" "])* "" (~["/"] (~[" "])* "") "/" > // Comentarios multilínea
  | < "//" (~["\r", "\n"])* ("\r" | "\n") > // Comentarios de una línea
}

// Tokens de palabras reservadas
TOKEN : {
    < FN: "fn" >
  | < LET: "let" >
  | < MUT: "mut" >
  | < RETURN: "return" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < ELSEIF: "else if" >
  | < WHILE: "while" >
  | < FOR: "for" >
  | < IN: "in" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < I32: "i32" >
  | < F64: "f64" >
  | < BOOL: "bool" >
  | < STR: "str" >
  | < STRING_KEYWORD: "String" >
  | < PRINTLN: "println!" >
  | < PRINT: "print!" >
}

// Tokens de operadores
TOKEN : {
    < PLUS: "+" >
  | < MINUS: "-" >
  | < MULTIPLICATION: "*" >
  | < DIVISION: "/" >
  | < MODULUS: "%" >
  | < EQUALTO: "==" >
  | < NOTEQUAL: "!=" >
  | < LESSTHAN: "<" >
  | < GREATERTHAN: ">" >
  | < LESSTHANEQUAL: "<=" >
  | < GREATERTHANEQUAL: ">=" >
  | < AND: "&&" >
  | < OR: "||" >
  | < NOT: "!" >
  | < EQUAL: "=" >
}

// Tokens de símbolos
TOKEN : {
    < LPARENT: "(" >
  | < RPARENT: ")" >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < COMMA: "," >
  | < PUNTOYCOMA: ";" >
  | < COLON: ":" >
  | < ARROW: "->" >
}

// Tokens de números y cadenas
TOKEN : {
    < INT: (["0"-"9"])+ >
  | < FLOAT: (["0"-"9"])+ "." (["0"-"9"])+ >
  | < STRING: "\"" (~["\""])* "\"" >
  | < IDENTIFIER: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
}

/** Fin Lexico **/

// Define el programa como una serie de declaraciones
void Program() : {}
{
    (Statement())*
}

// Define una declaración como una declaración de variable, una declaración de función, una estructura de control, una expresión o un bloque
void Statement() : {}
{
    VariableDeclaration()
  | FunctionDeclaration()
  | ControlStructure()
  | ExpressionStatement()
  | Block()
  | PrintStatement()
  | FunctionCallStatement()
}

// Define una declaración de variable
void VariableDeclaration() : {}
{
    <LET> [<MUT>] <IDENTIFIER> [":" Type()] "=" Expression() <PUNTOYCOMA>
}

// Define una declaración de función
void FunctionDeclaration() : {}
{
    <FN> <IDENTIFIER> <LPARENT> [ParameterList()] <RPARENT> [ <ARROW> Type() ] Block()
}

// Define una lista de parámetros de función
void ParameterList() : {}
{
    Parameter() ( <COMMA> Parameter() )* | ""
}

// Define un parámetro de función
void Parameter() : {}
{
    <IDENTIFIER> <COLON> Type()
}

// Define una estructura de control
void ControlStructure() : {}
{
    IfStatement()
  | WhileStatement()
  | ForStatement()
}

// Define una declaración if
void IfStatement() : {}
{
    <IF> Expression() Block() ( <ELSEIF> Expression() Block() )* [ <ELSE> Block() ]
}

// Define una declaración while
void WhileStatement() : {}
{
    <WHILE> Expression() Block()
}

// Define una declaración for
void ForStatement() : {}
{
    <FOR> <IDENTIFIER> <IN> <INT> ".." [<EQUAL> ] Expression() Block()
}

// Define un bloque de código
void Block() : {}
{
    <LBRACE> (Statement())* <RBRACE>
}

// Define una expresión
void ExpressionStatement() : {}
{
    Expression() <PUNTOYCOMA>
}

// Define una expresión, que puede ser un literal, un identificador, una llamada a función, una operación binaria, una operación unaria, o una expresión entre paréntesis
void Expression() : {}
{
    Assignment() | LogicalOrExpression()
}

// Define una asignación
void Assignment() : {}
{
    <IDENTIFIER> <EQUAL> Expression()
}

// Define una expresión lógica OR
void LogicalOrExpression() : {}
{
    LogicalAndExpression() ( <OR> LogicalAndExpression() )*
}

// Define una expresión lógica AND
void LogicalAndExpression() : {}
{
    EqualityExpression() ( <AND> EqualityExpression() )*
}

// Define una expresión de igualdad
void EqualityExpression() : {}
{
    RelationalExpression() ( ( <EQUALTO> | <NOTEQUAL> ) RelationalExpression() )*
}

// Define una expresión relacional
void RelationalExpression() : {}
{
    AdditiveExpression() ( ( <LESSTHAN> | <GREATERTHAN> | <LESSTHANEQUAL> | <GREATERTHANEQUAL> ) AdditiveExpression() )*
}

// Define una expresión aditiva
void AdditiveExpression() : {}
{
    MultiplicativeExpression() ( ( <PLUS> | <MINUS> ) MultiplicativeExpression() )*
}

// Define una expresión multiplicativa
void MultiplicativeExpression() : {}
{
    UnaryExpression() ( ( <MULTIPLICATION> | <DIVISION> | <MODULUS> ) UnaryExpression() )*
}

// Define una expresión unaria
void UnaryExpression() : {}
{
    <NOT> UnaryExpression() | PrimaryExpression()
}

// Define una expresión primaria
void PrimaryExpression() : {}
{
    Literal()
  | <IDENTIFIER>
  | FunctionCall()
  | <LPARENT> Expression() <RPARENT>
}

// Define un literal
void Literal() : {}
{
    <INT>
  | <FLOAT>
  | <STRING>
  | <TRUE>
  | <FALSE>
}

// Define una llamada a función
void FunctionCall() : {}
{
    <IDENTIFIER> <LPARENT> [ArgumentList()] <RPARENT>
}

// Define una declaración de llamada a función
void FunctionCallStatement() : {}
{
    FunctionCall() <PUNTOYCOMA>
}

// Define una lista de argumentos
void ArgumentList() : {}
{
    Expression() ( <COMMA> Expression() )* | ""
}

// Define un tipo de dato
void Type() : {}
{
    < I32 >
  | < F64 >
  | < BOOL >
  | < STR >
  | < STRING_KEYWORD >
  | < IDENTIFIER > // Para tipos definidos por el usuario
}

// Define una declaración de impresión
void PrintStatement() : {}
{
    (<PRINTLN> | <PRINT> ) <LPARENT> [ArgumentList()] <RPARENT> <PUNTOYCOMA>
}
